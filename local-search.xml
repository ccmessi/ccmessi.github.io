<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js数组常用方法</title>
    <link href="/2021/11/26/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/11/26/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ul><li><h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><p> 方法用于连接两个或多个数组。</p><p><strong>注：方法不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。</strong></p><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array1.concat(array2, array3, ..., arrayX)<br></code></pre></div></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sedan = [<span class="hljs-string">&quot;S60&quot;</span>, <span class="hljs-string">&quot;S90&quot;</span>];<br><span class="hljs-keyword">var</span> SUV = [<span class="hljs-string">&quot;XC40&quot;</span>, <span class="hljs-string">&quot;XC60&quot;</span>, <span class="hljs-string">&quot;XC90&quot;</span>];<br><span class="hljs-keyword">var</span> Volvo = sedan.concat(SUV);<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><p>方法向数组末尾添加新项目，并返回新长度。</p><p><strong>注：方法会改变数组的长度。</strong></p><p><strong>扩展：如需在数组的开头添加项目，请使用unshift()方法。</strong></p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.push(item1, item2, ..., itemX)<br></code></pre></div></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.push(<span class="hljs-string">&quot;Kiwi&quot;</span>);<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><p>方法移除数组的最后一个元素，并返回该元素。</p><p><strong>注：方法会改变数组的长度。</strong></p><p><strong>扩展：如需在数组的开头添加项目，请使用shift()方法。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.pop()<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.pop();<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>方法将数组缩减为单个值。</p><p><strong>注：对没有值的数组元素，不执行 reduce() 方法。reduce() 方法不会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total, currentValue, currentIndex, arr</span>), <span class="hljs-title">initialValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">175</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>];<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = numbers.reduce(myFunc);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">total, num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> total - num;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h5><p>方法向/从数组添加/删除项目，并返回删除的项目。</p><p><strong>注：方法会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.splice(index, howmany, item1, ....., itemX)<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Lemon&quot;</span>, <span class="hljs-string">&quot;Kiwi&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>方法返回包含所有数组值的字符串，以逗号分隔。</p><p><strong>注：方法不会改变原始数组。</strong></p><p><strong>扩展：返回包含所有数组值的数字，以逗号分隔可以用es6的Array.from()。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.toString()<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">var <span class="hljs-attr">fruits</span> = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>var <span class="hljs-attr">x</span> = fruits.<span class="hljs-built_in">toString</span>();<br></code></pre></div></td></tr></table></figure></li><li><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><p>使用为每个数组元素调用函数的结果创建新数组。按顺序为数组中的每个元素调用一次提供的函数。</p><p><strong>注： 不会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">65</span>, <span class="hljs-number">44</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> newarray = numbers.map(myFunction)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num * <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = newarray;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><p>方法创建数组，其中填充了所有通过测试的数组元素（作为函数提供）。</p><p><strong>注：不会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAdult</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = ages.filter(checkAdult);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h5><p>方法检查数组中的任何元素是否通过测试（作为函数提供）。</p><p><strong>注： 不改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAdult</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = ages.some(checkAdult);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h5><p>方法检查数组中的所有元素是否都通过了测试（被作为函数提供）。</p><p><strong>注： 不改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAdult</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = ages.every(checkAdult);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><p>方法将数组元素复制到数组中的另一个位置，覆盖现有值。</p><p><strong>注：方法会覆盖原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.copyWithin(target, start, end)<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.copyWithin(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指针详解</title>
    <link href="/2021/11/10/this%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/11/10/this%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="thist指向规则"><a href="#thist指向规则" class="headerlink" title="thist指向规则"></a>thist指向规则</h4><p>This指向分为四种绑定规则：默认绑定、隐式绑定、显式绑定以及关键字new绑定。在ES6之后，又有了箭头函数中的this规则。我们用实例看看，this在这些情况下的值是怎样的：</p><ol><li><h6 id="默认绑定、隐式绑定和显式绑定。"><a href="#默认绑定、隐式绑定和显式绑定。" class="headerlink" title="默认绑定、隐式绑定和显式绑定。"></a>默认绑定、隐式绑定和显式绑定。</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.bar); <br>&#125; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-string">&quot;bar1&quot;</span>; <br><span class="hljs-keyword">var</span> o2 = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bar2&quot;</span>, <span class="hljs-attr">foo</span>: foo&#125;; <br><span class="hljs-keyword">var</span> o3 = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bar3&quot;</span>, <span class="hljs-attr">foo</span>: foo&#125;; <br><br>foo();            <br>o2.foo();          <br>foo.call(o3); <br><span class="hljs-comment">// 输出：”bar1”, ”bar2”, ”bar3”</span><br></code></pre></div></td></tr></table></figure><ol start="2"><li><h6 id="SetTimeout等许多之后被触发的事件当中的this指向"><a href="#SetTimeout等许多之后被触发的事件当中的this指向" class="headerlink" title="SetTimeout等许多之后被触发的事件当中的this指向"></a>SetTimeout等许多之后被触发的事件当中的this指向</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Nicolas&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Smiley&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.sayName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <br>    &#125;;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>.sayName, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 第二次输出</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.sayName();<span class="hljs-comment">// 第一次输出</span><br><span class="hljs-comment">// 第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li><h6 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Smiley&quot;</span>;<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function">()=&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person();<br>person.sayName.call(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicolas&quot;</span>&#125;);<br><span class="hljs-comment">// 结果则为Person和Smiley。</span><br></code></pre></div></td></tr></table></figure><p>这是因为箭头函数并没有自己的this，被定义在哪里，this就指向谁，且优先级比显式调用高。</p><p>以上是本人总结的this指向问题，若有不对，请大家多多指教！</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uniapp环境部署</title>
    <link href="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="创建一个uniapp项目"><a href="#创建一个uniapp项目" class="headerlink" title="创建一个uniapp项目"></a>创建一个uniapp项目</h4><ol><li><h6 id="下载HBuilder以及微信开发者工具。"><a href="#下载HBuilder以及微信开发者工具。" class="headerlink" title="下载HBuilder以及微信开发者工具。"></a>下载HBuilder以及微信开发者工具。</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101214631961.png" alt="下载"></p></li><li><h6 id="打开HBuilder点击文件新建1-项目"><a href="#打开HBuilder点击文件新建1-项目" class="headerlink" title="打开HBuilder点击文件新建1.项目"></a>打开HBuilder点击文件新建1.项目</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185031980.png" alt="新建"></p></li><li><h6 id="点击创建"><a href="#点击创建" class="headerlink" title="点击创建"></a>点击创建</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185118860.png" alt="创建"></p></li><li><h6 id="创建完之后就自动生成uniapp的文件目录树"><a href="#创建完之后就自动生成uniapp的文件目录树" class="headerlink" title="创建完之后就自动生成uniapp的文件目录树"></a>创建完之后就自动生成uniapp的文件目录树</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185258926.png" alt="生成"></p></li><li><h6 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185340190.png" alt="运行"></p><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185546511.png" alt="运行结果"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一碗芋圆的碎碎念</title>
    <link href="/2021/10/29/%E4%B8%80%E7%A2%97%E8%8A%8B%E5%9C%86%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2021/10/29/%E4%B8%80%E7%A2%97%E8%8A%8B%E5%9C%86%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>爱情就是：白芋、紫芋、红豆、芋圆、牛奶————鲜鲜甜甜，每每回味，总有余香。</strong></p><p><img src="/2021/10/29/%E4%B8%80%E7%A2%97%E8%8A%8B%E5%9C%86%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/head.jpg" alt="相爱恨难"></p>]]></content>
    
    
    <categories>
      
      <category>-碎碎念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-爱情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端渲染</title>
    <link href="/2021/10/29/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <url>/2021/10/29/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<ul><li><h5 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h5><ul><li>说白了就是在服务端使用模板引擎</li><li>模板引擎最早诞生于服务端，后来才发展到了前端</li></ul></li><li><h5 id="服务端渲染和客户端渲染的区别"><a href="#服务端渲染和客户端渲染的区别" class="headerlink" title="服务端渲染和客户端渲染的区别"></a>服务端渲染和客户端渲染的区别</h5><ul><li>客户端渲染不利于 SEO 搜索引擎优化</li><li>服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的</li><li>所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的</li><li>而是两者结合来做的</li><li>例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化</li><li>而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-服务端渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暂时性死区</title>
    <link href="/2021/10/29/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/"/>
    <url>/2021/10/29/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-keyword">let</span> tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async问题</title>
    <link href="/2021/10/29/async%E9%97%AE%E9%A2%98/"/>
    <url>/2021/10/29/async%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h4><ol><li>async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</li></ol><ul><li>补充：<code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</li></ul><p>在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><ol start="2"><li><p>async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。await 表达式的运算结果取决于它等的东西：</p><p>（1）如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p><p>（2）如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p></li></ol><h4 id="两者的共同作用"><a href="#两者的共同作用" class="headerlink" title="两者的共同作用"></a>两者的共同作用</h4><p>async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeLongTime</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-string">&quot;long_time_value&quot;</span>), <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">await</span> takeLongTime();<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br>test();<br></code></pre></div></td></tr></table></figure><h4 id="async-await-的优势在于处理-then-链"><a href="#async-await-的优势在于处理-then-链" class="headerlink" title="async/await 的优势在于处理 then 链"></a>async/await 的优势在于处理 then 链</h4><ol><li>promise实现三个步骤的处理</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeLongTime</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step1</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step2</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step3</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><span class="hljs-comment">/*-----------------------------------------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    step1(time1)<br>        .then(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> step2(time2))<br>        .then(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> step3(time3))<br>        .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><br>doIt();<br></code></pre></div></td></tr></table></figure><h4 id="async-await-来实现"><a href="#async-await-来实现" class="headerlink" title="async/await 来实现"></a>async/await 来实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> step1(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> step2(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> step3(time3);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><br>doIt();<br></code></pre></div></td></tr></table></figure><p>代码看起来清晰得多，几乎跟同步代码一样!!!</p><h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>)<br>    <span class="hljs-keyword">await</span> async2()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;,<span class="hljs-number">0</span>)  <br>async1();<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">答案：<br><span class="hljs-keyword">script</span> start<br>async1 start<br>async2<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br>promise2<br>async1 <span class="hljs-keyword">end</span><br>setTimeout<br></code></pre></div></td></tr></table></figure><h5 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h5><ol><li>定义一个异步函数 async1</li><li>定义一个异步函数 async2</li><li>打印 ‘script start’ // *1</li><li>定义一个定时器（宏任务，优先级低于微任务），在0ms 之后输出</li><li>执行异步函数 async1<ol><li>打印 ‘async1 start’ // *2</li><li>遇到await 表达式，执行 await 后面的 async2<ol><li>打印 ‘async2’ // *3</li></ol></li><li>返回一个 Promise，跳出 async1 函数体</li></ol></li><li>执行 new Promise 里的语句<ol><li>打印 ‘promise1‘    // *4</li><li>resolve() , 返回一个 Promise 对象，把这个 Promise 压进队列里</li></ol></li><li>打印 ’script end’  // *5</li><li>同步栈执行完毕</li><li>回到 async1 的函数体，async2 函数没有返回 Promise，所以把要等async2 的值 resolve，把 Promise 压进队列</li><li>执行 new Promise 后面的 .then，打印 ’promise2‘ // *6</li><li>回到 async1 的函数体，await 返回 Promise.resolve() ，然后打印后面的 ’async1 end‘  // *7</li><li>最后执行定时器（宏任务） setTimeout，打印 ’setTimeout‘ // *8</li></ol><p>我对这段代码的过程分析大致如上（如果有什么理解不对的地方请指出），这里有很关键而且是大家容易理解错误的点是：很多人以为 await 会一直等待后面的表达式执行完之后才会执行后续代码，实际上 await 是会先执行后面的表达式，然后返回一个Promise，接着就跳出整个 async 函数来执行后面的代码，也就是说执行到 await 的时候，会有一个 <strong>让出线程</strong> 的操作。等后面的同步站执行完了之后，又会回到 async 函数中等待 await 表达式的返回值，如果不是一个 Promise 对象，则会有一个期待它 resolve 成为一个 Promise对象的过程，然后继续执行 async 函数后面的代码，直到是一个 Promise 对象，则把这个 Promise 对象放入 Promise 队列里。</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>节流与防抖</title>
    <link href="/2021/10/29/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <url>/2021/10/29/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h3 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//throttle本质也是一个定时器，在第一次触发事件的时候，开启定时器，在定时器执行完毕之前，系统会锁住，新触发的事件都不会执行；定时器执行完毕之后，销毁定时器，系统开放，接受新的事件。</span><br><span class="hljs-comment">//基本函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Throttle</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">//设置初始时间</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//设置当前时间</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">if</span> (now - pre &gt; delay) &#123;<br>      func.apply(context, args);<br>      pre = now<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>​        两个参数，第一个参数就是执行的函数，第二个参数是延迟的时间，用节流的方式，可以保证在一段时间内，只有第一次执行是生效的直到超过了设定的时间段，才有机会执行下一次，大大的降低了原有函数的执行频率。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//进阶节流函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, options</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> timeout, context, args, result;<br>  <span class="hljs-keyword">var</span> previous = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!options) options = &#123;&#125;;<br> <br>  <span class="hljs-keyword">var</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    previous = options.leading === <span class="hljs-literal">false</span>? <span class="hljs-number">0</span>: <span class="hljs-built_in">Date</span>.now(); <br>    timeout = <span class="hljs-literal">null</span>;<br>    result = func.apply(context, args);<br>  &#125;;<br> <br>  <span class="hljs-keyword">var</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">if</span> (!previous &amp;&amp; options.leading === <span class="hljs-literal">false</span>) previous = now;<br>    <span class="hljs-keyword">var</span> remaining = wait - (now - previous);<br>  context = <span class="hljs-built_in">this</span>;<br>    args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) &#123;<br>      <span class="hljs-keyword">if</span> (timeout) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;<br>      previous = now;<br>      result = func.apply(context, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(later, remaining);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  throttled.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    previous = <span class="hljs-number">0</span>;<br>    timeout = context = args = <span class="hljs-literal">null</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> throttled;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//debounce本质上，是一个定时器setTimeout，在wait毫秒时间之后，执行传入的函数：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout, result;<br> <br>    <span class="hljs-keyword">var</span> debounced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>  <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br> <br>        <span class="hljs-keyword">var</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           timeout = <span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">if</span> (!immediate) result = func.apply(context, args);<br>        &#125;;<br> <br> <br>        <span class="hljs-keyword">var</span> callNow = immediate &amp;&amp; !timeout;<br>        timeout = <span class="hljs-built_in">setTimeout</span>(later, wait);<br>        <span class="hljs-keyword">if</span> (callNow) result = func.apply(<span class="hljs-built_in">this</span>, args);<br> <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    debounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        timeout = <span class="hljs-literal">null</span>;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> debounced;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        返回 <strong>function</strong> 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 <strong>wait</strong> 毫秒之后. 对于必须在一些输入（多是一些用户操作）停止到达<em>之后</em>执行的行为有帮助。 例如: 渲染一个Markdown格式的评论预览, 当窗口停止改变大小之后重新计算布局, 等等.</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-throttle&amp;debounce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios</title>
    <link href="/2021/10/28/axios/"/>
    <url>/2021/10/28/axios/</url>
    
    <content type="html"><![CDATA[<h4 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h4><h5 id="1-请求地址以及超时时间"><a href="#1-请求地址以及超时时间" class="headerlink" title="1.请求地址以及超时时间"></a>1.请求地址以及超时时间</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://tomcat2-69.gis-data.cn:7080&#x27;</span>,<br>  <span class="hljs-comment">// 超时时间</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="2-设置请求拦截器"><a href="#2-设置请求拦截器" class="headerlink" title="2.设置请求拦截器"></a>2.设置请求拦截器</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">service.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  config.data = <span class="hljs-built_in">JSON</span>.stringify(config.data); <span class="hljs-comment">//数据转化,也可以使用qs转换</span><br>  config.headers = &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=UTF-8&#x27;</span> <span class="hljs-comment">//配置请求头</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> config<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">Promise</span>.reject(error)<br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="3-设置响应拦截器"><a href="#3-设置响应拦截器" class="headerlink" title="3.设置响应拦截器"></a>3.设置响应拦截器</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">service.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 接收到响应数据并成功后的一些共有的处理，关闭loading等</span><br><br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">/***** 接收到异常响应的处理开始 *****/</span><br>  <span class="hljs-keyword">if</span> (error &amp;&amp; error.response) &#123;<br>    <span class="hljs-comment">// 根据响应码具体处理</span><br>    <span class="hljs-keyword">switch</span> (error.response.status) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">400</span>:<br>        error.message = <span class="hljs-string">&#x27;错误请求&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:<br>        error.message = <span class="hljs-string">&#x27;未授权，请重新登录&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:<br>        error.message = <span class="hljs-string">&#x27;拒绝访问&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:<br>        error.message = <span class="hljs-string">&#x27;请求错误,未找到该资源&#x27;</span>;<br>        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;/NotFound&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">405</span>:<br>        error.message = <span class="hljs-string">&#x27;请求方法未允许&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">408</span>:<br>        error.message = <span class="hljs-string">&#x27;请求超时&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:<br>        error.message = <span class="hljs-string">&#x27;服务器端出错&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">501</span>:<br>        error.message = <span class="hljs-string">&#x27;网络未实现&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">502</span>:<br>        error.message = <span class="hljs-string">&#x27;网络错误&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">503</span>:<br>        error.message = <span class="hljs-string">&#x27;服务不可用&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">504</span>:<br>        error.message = <span class="hljs-string">&#x27;网络超时&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">505</span>:<br>        error.message = <span class="hljs-string">&#x27;http版本不支持该请求&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        error.message = <span class="hljs-string">`连接错误<span class="hljs-subst">$&#123;error.response.status&#125;</span>`</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 超时处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">JSON</span>.stringify(error).includes(<span class="hljs-string">&#x27;timeout&#x27;</span>)) &#123;<br>      Message.error(<span class="hljs-string">&#x27;服务器响应超时，请刷新当前页&#x27;</span>)<br>    &#125;<br>    error.message = <span class="hljs-string">&#x27;连接服务器失败&#x27;</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-返回错误信息，处理结束，最后导出"><a href="#4-返回错误信息，处理结束，最后导出" class="headerlink" title="4.返回错误信息，处理结束，最后导出"></a>4.返回错误信息，处理结束，最后导出</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"> Message.error(error.message);<br>  <span class="hljs-comment">/***** 处理结束 *****/</span><br>  <span class="hljs-comment">//如果不需要错误处理，以上的处理过程都可省略</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(error.response)<br>&#125;);<br><span class="hljs-comment">//导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cloud</title>
    <link href="/2021/10/28/cloud/"/>
    <url>/2021/10/28/cloud/</url>
    
    <content type="html"><![CDATA[<p>人生如戏,亦或是戏如人生。</p>]]></content>
    
    
    <categories>
      
      <category>-随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise</title>
    <link href="/2021/10/28/promise/"/>
    <url>/2021/10/28/promise/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//异步加载</span><br><span class="hljs-built_in">this</span>.promise = Cesium.GeoJsonDataSource.load(<br>  <span class="hljs-string">&#x27; http://nginx-100.gis-data.cn:7080/learning/3/cq-boundary.geojson&#x27;</span>, &#123;<br>    <span class="hljs-attr">stroke</span>: Cesium.Color.BLUE,<br>    <span class="hljs-attr">fill</span>: Cesium.Color.RED,<br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">8</span>,<br>  &#125;);<br><span class="hljs-built_in">this</span>.promise.then(<span class="hljs-function">(<span class="hljs-params">dataSource</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">this</span>.viewer.dataSources.add(dataSource);<br>  <span class="hljs-keyword">let</span> entities = dataSource.entities.values;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entity <span class="hljs-keyword">of</span> entities) &#123;<br>    <span class="hljs-keyword">let</span> polyPositions = entity.polygon.hierarchy.getValue(Cesium.JulianDate.now()).positions;<br>    <span class="hljs-comment">// 方式一：</span><br>    <span class="hljs-comment">// let polyCenter = Cesium.BoundingSphere.fromPoints(polyPositions).center;</span><br>    <span class="hljs-comment">// polyCenter = Cesium.Ellipsoid.WGS84.scaleToGeodeticSurface(polyCenter);</span><br>    <span class="hljs-comment">// 方式二：</span><br>    <span class="hljs-keyword">let</span> center = [];<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= polyPositions.length - <span class="hljs-number">1</span>; j++) &#123;<br>      a += polyPositions[j].x;<br>      b += polyPositions[j].y;<br>      c += polyPositions[j].z<br>    &#125;<br>    center = [a / polyPositions.length, b / polyPositions.length, c / polyPositions.length + <span class="hljs-number">2000</span>];<br>    <span class="hljs-keyword">let</span> labelpostion = Cesium.Cartesian3.fromArray(center);<br>    <span class="hljs-comment">//方式三：暂未实现，后面会继续研究</span><br>    <span class="hljs-comment">// let cartographics = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(polyPositions);</span><br>    <span class="hljs-comment">// let points = [];</span><br>    <span class="hljs-comment">// let center = [];</span><br>    <span class="hljs-comment">// let a = 0;</span><br>    <span class="hljs-comment">// for (let i = 0; i &lt;= cartographics.length - 1; i++) &#123;</span><br>    <span class="hljs-comment">//   let lat = Cesium.Math.toDegrees(cartographics[i].latitude);</span><br>    <span class="hljs-comment">//   let lng = Cesium.Math.toDegrees(cartographics[i].longitude);</span><br>    <span class="hljs-comment">//   a = cartographics[i].height;</span><br>    <span class="hljs-comment">//   points[i] = [lng, lat];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// let polygon = Turf.polygon([points]);</span><br>    <span class="hljs-comment">// let centroid = Turf.centroid(polygon);</span><br>    <span class="hljs-comment">// center = [centroid.geometry.coordinates[0], centroid.geometry.coordinates[1]];</span><br>    <span class="hljs-comment">// let labelpostion = Cesium.Cartesian3.fromDegreesArray(center);</span><br>    <span class="hljs-built_in">this</span>.viewer.entities.add(&#123;<br>      <span class="hljs-attr">position</span>: labelpostion,<br>      <span class="hljs-attr">label</span>: &#123;<br>        <span class="hljs-attr">font</span>: <span class="hljs-string">&#x27;24px sans-serif&#x27;</span>,<br>        <span class="hljs-attr">text</span>: entity.name,<br>        <span class="hljs-attr">scale</span>: <span class="hljs-number">0.5</span>,<br>        <span class="hljs-attr">horizontalOrigin</span>: Cesium.HorizontalOrigin.CENTER,<br>        <span class="hljs-attr">verticalOrigin</span>: Cesium.VerticalOrigin.BOTTOM,<br>        <span class="hljs-attr">fillColor</span>: Cesium.Color.CRIMSON,<br>        <span class="hljs-attr">showBackground</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">backgroundColor</span>: Cesium.Color.BEIGE,<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>promise这个类最基本的功能就是传入处理器函数executor。根据MDN上的解释：</p><blockquote><p>这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。</p><p>promise中有三个状态：pending，fulfilled以及rejected。在上面这段程序中，使用this.$state来保存promise的状态。</p><p>而resolve和reject的函数定义当中，传入的参数res赋给this.$value，从而实现参数res的传递。</p><p>最后，调用executor，并把resolve和reject当做两个参数传递进去。如果这中间出现异常，我们会认为这是操作失败，从而调用reject函数。</p></blockquote><ul><li>在我的项目中，当执行cesium的Cesium.GeoJsonDataSource.load这个加载json格式的数据的函数时，会返回一个promise对象，此时promise对象resolve里储存的是entities实体数据集：它包括这个json数据的所有面的坐标数据，promise一般用.then方法获取resolve存储的数据，并且在then方法里的js都是异步进行的，在promise外面是获取不到这个数据的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
