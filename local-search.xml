<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>简单实现vue得双向绑定</title>
    <link href="/2021/12/26/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0vue%E5%BE%97%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/12/26/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0vue%E5%BE%97%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p><strong>直接上代码</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Book = &#123;&#125;;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-built_in">Object</span>.defineProperty(Book,<span class="hljs-string">&#x27;name&#x27;</span>,&#123;<br>    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        name = value;<br>        <span class="hljs-built_in">console</span>.log(name)<br>    &#125;,<br>    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;《&#x27;</span> + name + <span class="hljs-string">&#x27;》&#x27;</span><br>    &#125;<br>&#125;)<br>Book.name = <span class="hljs-string">&#x27;肖生客的救赎&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(Book.name);<br><span class="hljs-built_in">console</span>.log(Book)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用算法</title>
    <link href="/2021/12/26/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2021/12/26/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>len = arr.length;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;<br>      <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;    <span class="hljs-string">``</span><span class="hljs-comment">// 相邻元素两两对比</span><br>        <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>temp = arr[j+<span class="hljs-number">1</span>];    <span class="hljs-string">``</span><span class="hljs-comment">// 元素交换</span><br>        <span class="hljs-string">``</span>arr[j+<span class="hljs-number">1</span>] = arr[j];<br>        <span class="hljs-string">``</span>arr[j] = temp;<br>      <span class="hljs-string">``</span>&#125;<br>    <span class="hljs-string">``</span>&#125;<br>  <span class="hljs-string">``</span>&#125;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">``</span>arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li><p>初始状态：无序区为R[1..n]，有序区为空；</p></li><li><p>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p></li><li><p>n-1趟结束，数组有序化了。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>len = arr.length;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>minIndex, temp;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-string">``</span>minIndex = i;<br>    <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>      <span class="hljs-string">``</span><span class="hljs-keyword">if</span><span class="hljs-string">``</span>(arr[j] &lt; arr[minIndex]) &#123;  <span class="hljs-string">``</span><span class="hljs-comment">// 寻找最小的数</span><br>        <span class="hljs-string">``</span>minIndex = j;        <span class="hljs-string">``</span><span class="hljs-comment">// 将最小数的索引保存</span><br>      <span class="hljs-string">``</span>&#125;<br>    <span class="hljs-string">``</span>&#125;<br>    <span class="hljs-string">``</span>temp = arr[i];<br>    <span class="hljs-string">``</span>arr[i] = arr[minIndex];<br>    <span class="hljs-string">``</span>arr[minIndex] = temp;<br>  <span class="hljs-string">``</span>&#125;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">``</span>arr;<br>&#125; <br></code></pre></div></td></tr></table></figure></li></ul><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>len = arr.length;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>preIndex, current;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-string">``</span>preIndex = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-string">``</span>current = arr[i];<br>    <span class="hljs-string">``</span><span class="hljs-keyword">while</span><span class="hljs-string">``</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>      <span class="hljs-string">``</span>arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>      <span class="hljs-string">``</span>preIndex--;<br>    <span class="hljs-string">``</span>&#125;<br>    <span class="hljs-string">``</span>arr[preIndex + <span class="hljs-number">1</span>] = current;<br>  <span class="hljs-string">``</span>&#125;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">``</span>arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>len = arr.length;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>gap = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>); gap &gt; <span class="hljs-number">0</span>; gap = <span class="hljs-built_in">Math</span>.floor(gap / <span class="hljs-number">2</span>)) &#123;<br>    <span class="hljs-string">``</span><span class="hljs-comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br>    <span class="hljs-string">``</span><span class="hljs-keyword">for</span><span class="hljs-string">``</span>(<span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>i = gap; i &lt; len; i++) &#123;<br>      <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>j = i;<br>      <span class="hljs-string">``</span><span class="hljs-keyword">var</span><span class="hljs-string">``</span>current = arr[i];<br>      <span class="hljs-string">``</span><span class="hljs-keyword">while</span><span class="hljs-string">``</span>(j - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;<br>         <span class="hljs-string">``</span>arr[j] = arr[j - gap];<br>         <span class="hljs-string">``</span>j = j - gap;<br>      <span class="hljs-string">``</span>&#125;<br>      <span class="hljs-string">``</span>arr[j] = current;<br>    <span class="hljs-string">``</span>&#125;<br>  <span class="hljs-string">``</span>&#125;<br>  <span class="hljs-string">``</span><span class="hljs-keyword">return</span><span class="hljs-string">``</span>arr;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie</title>
    <link href="/2021/12/26/cookie/"/>
    <url>/2021/12/26/cookie/</url>
    
    <content type="html"><![CDATA[<p><strong>如何设置一个</strong> <strong>cookie</strong></p><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p><p>服务端是通过 setCookie 的响应头来设置 cookie 的，要设置多个 cookie 时，得多写几个 setCookie。服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个 Set-Cookie 字段。</p><p>前端使用 document.cookie 属性来读写当前网页的 Cookie。写入的时候，Cookie 的值必须写成 key=value 的形式。</p><p>Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB。</p><p><strong>如何删除一个</strong> <strong>cookie</strong></p><p>通过把该 <code>cookie</code> 的过期时间改为过去时即可删除成功，具体操作的话可以通过操作两个字段来完成</p><ol><li><code>max-age</code>: 将要过期的最大秒数，设置为 <code>-1</code> 即可删除</li><li><code>expires</code>: 将要过期的绝对时间，存储到 <code>cookies</code> 中需要通过 <code>date.toUTCString()</code> 处理，设置为过期时间即可删除</li></ol><p>很明显，<code>max-age</code> 更为简单，以下代码可在命令行控制台中进行测试</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// max-age 设置为 -1 即可成功</span><br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;a=3; max-age=-1&quot;</span>;<br>&gt; <span class="hljs-built_in">document</span>.cookie<br>&lt; <span class="hljs-string">&quot;&quot;</span><br><br>&gt; <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;a=3&#x27;</span><br>&lt; <span class="hljs-string">&quot;a=3&quot;</span><br><br>&gt; <span class="hljs-built_in">document</span>.cookie<br>&lt; <span class="hljs-string">&quot;a=3&quot;</span><br><br><span class="hljs-comment">// 把该字段的 max-age 设置为 -1</span><br>&gt; <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;a=3; max-age=-1&#x27;</span><br>&lt; <span class="hljs-string">&quot;a=3; max-age=-1&quot;</span><br><br><span class="hljs-comment">// 删除成功</span><br>&gt; <span class="hljs-built_in">document</span>.cookie<br>&lt; <span class="hljs-string">&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>同时，也可以使用最新关于 cookie 操作的 API: <code>CookieStorea API</code> 其中的 <code>cookieStore.delete(name)</code> 删除某个 cookie</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片懒加载</title>
    <link href="/2021/12/26/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/12/26/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在当前网页，滑动页面到能看到图片的时候再加载图片。</p><p>故问题拆分成两个：</p><ol><li>如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）</li><li>如何控制图片的加载</li></ol><h4 id="方案一-位置计算-滚动事件-Scroll-DataSet-API"><a href="#方案一-位置计算-滚动事件-Scroll-DataSet-API" class="headerlink" title="方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API"></a>方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API</h4><p>首先，<code>clientTop</code>，<code>offsetTop</code>，<code>clientHeight</code> 以及 <code>scrollTop</code> 各种关于图片的高度作比对，这些高度都代表了什么意思？</p><p>这里是javascript中制作滚动代码的常用属性</p><p>页可见区域宽： document.body.clientWidth;<br>网页可见区域高： document.body.clientHeight;</p><p>window.innerHeight;<br>网页可见区域宽： document.body.offsetWidth  (包括边线的宽);<br>网页可见区域高： document.body.offsetHeight (包括边线的宽);<br>网页正文全文宽： document.body.scrollWidth;<br>网页正文全文高： document.body.scrollHeight;<br>网页被卷去的高： document.body.scrollTop;<br>网页被卷去的左： document.body.scrollLeft;<br>网页正文部分上： window.screenTop;<br>网页正文部分左： window.screenLeft;<br>屏幕分辨率的高： window.screen.height;<br>屏幕分辨率的宽： window.screen.width;</p><p>屏幕可用工作区高度： window.screen.availHeight;</p><p><img src="/2021/12/26/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/top.jpg" alt="浏览器滚动常用属性"></p><p>仅仅知道它静态的高度还不够，我们还需要知道动态的,实现<strong>动态</strong>就需要监听 <code>window.scroll</code> 事件。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">//控制图片的加载<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;shanyue.jpg&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>首先设置一个临时 Data 属性 <code>data-src</code>，控制加载时使用 <code>src</code> 代替 <code>data-src</code>，可利用 DataSet API 实现</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">img.src = img.datset.src<br></code></pre></div></td></tr></table></figure><h4 id="方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API"><a href="#方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API" class="headerlink" title="方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API"></a>方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API</h4><p>关键在于判断<strong>图片出现在了当前视口</strong></p><p>可以引入一个新的 API， <strong><code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置。</strong></p><p><img src="/2021/12/26/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/rect.png" alt="图片视口"></p><p>那如何判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// clientHeight 代表当前视口的高度</span><br>img.getBoundingClientRect().top &lt; <span class="hljs-built_in">document</span>.documentElement.clientHeight;<br></code></pre></div></td></tr></table></figure><p><strong>监听 <code>window.scroll</code> 事件也优化一下</strong></p><p>加个节流器，提高性能。工作中一般使用 <code>lodash.throttle</code> 就可以了，万能的 <code>lodash</code> 啊！</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">_.throttle(func, [(wait = <span class="hljs-number">0</span>)], [(options = &#123;&#125;)]);<br></code></pre></div></td></tr></table></figure><h4 id="方案三-IntersectionObserver-API-DataSet-API"><a href="#方案三-IntersectionObserver-API-DataSet-API" class="headerlink" title="方案三: IntersectionObserver API + DataSet API"></a>方案三: IntersectionObserver API + DataSet API</h4><p><code>IntersectionObserver</code> API，一个能够监听元素是否到了当前视口的事件，一步到位！</p><p>事件回调的参数是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry">IntersectionObserverEntry (opens new window)</a>的集合，代表关于是否在可见视口的一系列值。</p><p>其中，<code>entry.isIntersecting</code> 代表目标元素可见。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function">(<span class="hljs-params">changes</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// changes: 目标元素集合</span><br>  changes.forEach(<span class="hljs-function">(<span class="hljs-params">change</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// intersectionRatio</span><br>    <span class="hljs-keyword">if</span> (change.isIntersecting) &#123;<br>      <span class="hljs-keyword">const</span> img = change.target;<br>      img.src = img.dataset.src;<br>      observer.unobserve(img);<br>    &#125;<br>  &#125;);<br>&#125;);<br><br>observer.observe(img);<br></code></pre></div></td></tr></table></figure><h4 id="方案四-lazyloading-属性方案四-LazyLoading-属性"><a href="#方案四-lazyloading-属性方案四-LazyLoading-属性" class="headerlink" title="方案四-lazyloading-属性方案四: LazyLoading 属性"></a>方案四-lazyloading-属性方案四: LazyLoading 属性</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;shanyue.jpg&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>不过目前浏览器兼容性不太好。</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中computed的原理</title>
    <link href="/2021/12/26/vue%E4%B8%ADcomputed%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/12/26/vue%E4%B8%ADcomputed%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>要讲清楚，computed 原理，首先得讲 vue 响应式原理，因为 computed 的实现是基于 Watcher 对象的。 那么 vue 的响应式原理是什么呢，众所周知，vue 是基于 Object.defineProperty 实现监听的。在 vue 初始化数据 data 和 computed 数据过程中。会涉及到以下几个对象：</p><ol><li>Observe 对象</li><li>Dep 对象</li><li>Watch 对象 Observe 对象是在 data 执行响应式时候调用，因为 computed 属性基于响应式属性，所以其不需要创建 Observe 对象。 Dep 对象主要功能是做依赖收集，有个属性维护多个 Watch 对象，当更新时候循环调用每个 Watch 执行更新。 Watch 对象主要是用于更新，而且是收集的重点对象。</li></ol><p>这里谈到 computed 计算属性，首先要知道，其有两种定义方式，一种是方法，另一种是 get，set 属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如 data 的属性 vuex 的属性。</p><p>vue 在创建 computed 属性时候，会循环所有计算属性，每一个计算属性会创建一个 watch，并且在通过 defineProperty 定义监听，在 get 中，计算属性工作是做依赖收集，在 set 中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为 computed 是懒执行，也就是说第一次初始化之后，变不会执行计算，下一次变更执行重新计算是在 set 中。</p><p>另一个补充点是依赖收集的时机，computed 收集时机和 data 一样，是在组件挂载前，但是其收集对象是自己属性对应的 watch，而 data 本身所有数据对应一个 watch。</p><p>以下附计算属性源码验证说法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initComputed</span>(<span class="hljs-params">vm: Component, computed: <span class="hljs-built_in">Object</span></span>) </span>&#123;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">const</span> watchers = (vm._computedWatchers = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>));<br>  <span class="hljs-comment">// computed properties are just getters during SSR</span><br>  <span class="hljs-keyword">const</span> isSSR = isServerRendering();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    <span class="hljs-keyword">const</span> userDef = computed[key];<br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&quot;function&quot;</span> ? userDef : userDef.get;<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&quot;production&quot;</span> &amp;&amp; getter == <span class="hljs-literal">null</span>) &#123;<br>      warn(<span class="hljs-string">`Getter is missing for computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot;.`</span>, vm);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!isSSR) &#123;<br>      <span class="hljs-comment">// create internal watcher for the computed property.</span><br>      watchers[key] = <span class="hljs-keyword">new</span> Watcher(<br>        vm,<br>        getter || noop,<br>        noop,<br>        computedWatcherOptions<br>      );<br>    &#125;<br><br>    <span class="hljs-comment">// component-defined computed properties are already defined on the</span><br>    <span class="hljs-comment">// component prototype. We only need to define computed properties defined</span><br>    <span class="hljs-comment">// at instantiation here.</span><br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;<br>      defineComputed(vm, key, userDef);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&quot;production&quot;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> vm.$data) &#123;<br>        warn(<span class="hljs-string">`The computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vm.$options.props &amp;&amp; key <span class="hljs-keyword">in</span> vm.$options.props) &#123;<br>        warn(<br>          <span class="hljs-string">`The computed property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already defined as a prop.`</span>,<br>          vm<br>        );<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，在执行 new Watcher 之前，会对计算属性做判断，判断其是否为函数，如果不是则取 getter。这是因为计算属性有两种定义方式。之后第二步是执行 deineCoumputed。这一步只是简单的调用 defineProterty 我就不贴代码了。</p><p>关于计算属性的 getter 和 setter 定义如下： 重点关注 get 的懒加载部分，和 Watcher 的定义：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createComputedGetter</span>(<span class="hljs-params">key</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computedGetter</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> watcher = <span class="hljs-built_in">this</span>._computedWatchers &amp;&amp; <span class="hljs-built_in">this</span>._computedWatchers[key];<br>    <span class="hljs-keyword">if</span> (watcher) &#123;<br>      <span class="hljs-keyword">if</span> (watcher.dirty) &#123;<br>        watcher.evaluate();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>        watcher.depend();<br>      &#125;<br>      <span class="hljs-keyword">return</span> watcher.value;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGetterInvoker</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computedGetter</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>);<br>  &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数柯里化</title>
    <link href="/2021/12/19/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2021/12/19/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="函数柯里化的定义"><a href="#函数柯里化的定义" class="headerlink" title="函数柯里化的定义"></a>函数柯里化的定义</h3><p>避免频繁调用具有相同参数的函数，同时能够轻松的复用。简而言之，就是避免重复调用带有相同参数的函数。例如：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width,height</span>) </span>&#123;<br><span class="hljs-keyword">return</span> width + height:<br>&#125;<br><br><span class="hljs-keyword">const</span> area1 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br><span class="hljs-keyword">const</span> area2 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);<br><span class="hljs-keyword">const</span> area3 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">40</span>);<br><span class="hljs-keyword">const</span> area4 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">50</span>);<br><span class="hljs-comment">//此时频繁调用了带有10这个参数的getArea()这个函数</span><br><br><span class="hljs-comment">//函数柯里化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">width</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">height</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> width + height:<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> getTenWidthArea = getArea(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">const</span> area1 = getTenWidthArea(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">const</span> area2 = getTenWidthArea(<span class="hljs-number">30</span>);<br><span class="hljs-keyword">const</span> area3 = getTenWidthArea(<span class="hljs-number">40</span>);<br><span class="hljs-keyword">const</span> area4 = getTenWidthArea(<span class="hljs-number">50</span>);<br></code></pre></div></td></tr></table></figure><p>此处我们巧妙运用了一个闭包函数将函数柯里化。</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2021/11/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/11/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h5 id="垃圾回收机制及其应用场景"><a href="#垃圾回收机制及其应用场景" class="headerlink" title="垃圾回收机制及其应用场景"></a>垃圾回收机制及其应用场景</h5><p>应用程序在运行过程中需要占用一定的内存空间，且在运行过后就必须将不再用到的内存释放掉，否则就会出现下图中内存的占用持续升高的情况，一方面会影响程序的运行速度，另一方面严重的话则会导致整个程序的崩溃。</p><ol><li><h6 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">text</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a1 = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment">//未声明变量的写法，等价于a1 === window.a1</span><br>    <span class="hljs-built_in">this</span>.a2 = <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">//等价于a2 === window.a2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>全局变量会挂载在window下；</li><li>全局变量至少有一个引用计数；</li><li>全局变量存活更久，持续占用内存；</li><li>在明确数据作用域的情况下，尽量使用局部变量；</li></ul><ol start="2"><li><h6 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//dom操作</span><br>    <span class="hljs-comment">//使用了ajaxData</span><br>&#125;，<span class="hljs-number">5000</span>)；<span class="hljs-comment">// ajaxData在。定时器也会一直驻在</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeAdder</span>(<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> z = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y + z;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> add5 = makeAdder(<span class="hljs-number">5</span>);<br><br><span class="hljs-built_in">console</span>.log(add5(<span class="hljs-number">2</span>));<br><span class="hljs-comment">// 变量z常驻</span><br></code></pre></div></td></tr></table></figure><ol start="4"><li>dom操作</li><li>时间操作</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;skip&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;skip&quot;</span>&gt;&lt;/div&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> oBox = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;skip&#x27;</span>)</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// function hasEle (ele, cls) &#123;</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//     return ele.className === cls</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasEle</span> (<span class="hljs-params">ele, cls</span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">const</span> className = ele.className</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> className === cls</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(hasEle(oBox, <span class="hljs-string">&#x27;skip&#x27;</span>))</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>放入数组中，数组执行之后，依然存在引用</p><p>解决方案：及时清除引用（dom，闭包，定时器）；减少不必要的全局变量（开启严格模式）等</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数组常用方法</title>
    <link href="/2021/11/26/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/11/26/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ul><li><h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><p> 方法用于连接两个或多个数组。</p><p><strong>注：方法不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。</strong></p><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array1.concat(array2, array3, ..., arrayX)<br></code></pre></div></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sedan = [<span class="hljs-string">&quot;S60&quot;</span>, <span class="hljs-string">&quot;S90&quot;</span>];<br><span class="hljs-keyword">var</span> SUV = [<span class="hljs-string">&quot;XC40&quot;</span>, <span class="hljs-string">&quot;XC60&quot;</span>, <span class="hljs-string">&quot;XC90&quot;</span>];<br><span class="hljs-keyword">var</span> Volvo = sedan.concat(SUV);<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><p>方法向数组末尾添加新项目，并返回新长度。</p><p><strong>注：方法会改变数组的长度。</strong></p><p><strong>扩展：如需在数组的开头添加项目，请使用unshift()方法。</strong></p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.push(item1, item2, ..., itemX)<br></code></pre></div></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.push(<span class="hljs-string">&quot;Kiwi&quot;</span>);<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><p>方法移除数组的最后一个元素，并返回该元素。</p><p><strong>注：方法会改变数组的长度。</strong></p><p><strong>扩展：如需在数组的开头添加项目，请使用shift()方法。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.pop()<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.pop();<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>方法将数组缩减为单个值。</p><p><strong>注：对没有值的数组元素，不执行 reduce() 方法。reduce() 方法不会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total, currentValue, currentIndex, arr</span>), <span class="hljs-title">initialValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">175</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>];<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = numbers.reduce(myFunc);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">total, num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> total - num;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><ul><li><h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h5><p>方法向/从数组添加/删除项目，并返回删除的项目。</p><p><strong>注：方法会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.splice(index, howmany, item1, ....., itemX)<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Lemon&quot;</span>, <span class="hljs-string">&quot;Kiwi&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>方法返回包含所有数组值的字符串，以逗号分隔。</p><p><strong>注：方法不会改变原始数组。</strong></p><p><strong>扩展：返回包含所有数组值的数字，以逗号分隔可以用es6的Array.from()。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.toString()<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">var <span class="hljs-attr">fruits</span> = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>var <span class="hljs-attr">x</span> = fruits.<span class="hljs-built_in">toString</span>();<br></code></pre></div></td></tr></table></figure></li><li><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><p>使用为每个数组元素调用函数的结果创建新数组。按顺序为数组中的每个元素调用一次提供的函数。</p><p><strong>注： 不会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">65</span>, <span class="hljs-number">44</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> newarray = numbers.map(myFunction)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num * <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = newarray;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><p>方法创建数组，其中填充了所有通过测试的数组元素（作为函数提供）。</p><p><strong>注：不会改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAdult</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = ages.filter(checkAdult);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h5><p>方法检查数组中的任何元素是否通过测试（作为函数提供）。</p><p><strong>注： 不改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAdult</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = ages.some(checkAdult);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h5><p>方法检查数组中的所有元素是否都通过了测试（被作为函数提供）。</p><p><strong>注： 不改变原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)</span><br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">16</span>, <span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAdult</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = ages.every(checkAdult);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><p>方法将数组元素复制到数组中的另一个位置，覆盖现有值。</p><p><strong>注：方法会覆盖原始数组。</strong></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">array.copyWithin(target, start, end)<br></code></pre></div></td></tr></table></figure><p><strong>例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br>fruits.copyWithin(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指针详解</title>
    <link href="/2021/11/10/this%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/11/10/this%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="thist指向规则"><a href="#thist指向规则" class="headerlink" title="thist指向规则"></a>thist指向规则</h4><p>This指向分为四种绑定规则：默认绑定、隐式绑定、显式绑定以及关键字new绑定。在ES6之后，又有了箭头函数中的this规则。我们用实例看看，this在这些情况下的值是怎样的：</p><ol><li><h6 id="默认绑定、隐式绑定和显式绑定。"><a href="#默认绑定、隐式绑定和显式绑定。" class="headerlink" title="默认绑定、隐式绑定和显式绑定。"></a>默认绑定、隐式绑定和显式绑定。</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.bar); <br>&#125; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-string">&quot;bar1&quot;</span>; <br><span class="hljs-keyword">var</span> o2 = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bar2&quot;</span>, <span class="hljs-attr">foo</span>: foo&#125;; <br><span class="hljs-keyword">var</span> o3 = &#123;<span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bar3&quot;</span>, <span class="hljs-attr">foo</span>: foo&#125;; <br><br>foo();            <br>o2.foo();          <br>foo.call(o3); <br><span class="hljs-comment">// 输出：”bar1”, ”bar2”, ”bar3”</span><br></code></pre></div></td></tr></table></figure><ol start="2"><li><h6 id="SetTimeout等许多之后被触发的事件当中的this指向"><a href="#SetTimeout等许多之后被触发的事件当中的this指向" class="headerlink" title="SetTimeout等许多之后被触发的事件当中的this指向"></a>SetTimeout等许多之后被触发的事件当中的this指向</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Nicolas&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Smiley&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.sayName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <br>    &#125;;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>.sayName, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 第二次输出</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.sayName();<span class="hljs-comment">// 第一次输出</span><br><span class="hljs-comment">// 第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li><h6 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Smiley&quot;</span>;<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function">()=&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person();<br>person.sayName.call(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicolas&quot;</span>&#125;);<br><span class="hljs-comment">// 结果则为Person和Smiley。</span><br></code></pre></div></td></tr></table></figure><p>这是因为箭头函数并没有自己的this，被定义在哪里，this就指向谁，且优先级比显式调用高。</p><p>以上是本人总结的this指向问题，若有不对，请大家多多指教！</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uniapp环境部署</title>
    <link href="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="创建一个uniapp项目"><a href="#创建一个uniapp项目" class="headerlink" title="创建一个uniapp项目"></a>创建一个uniapp项目</h4><ol><li><h6 id="下载HBuilder以及微信开发者工具。"><a href="#下载HBuilder以及微信开发者工具。" class="headerlink" title="下载HBuilder以及微信开发者工具。"></a>下载HBuilder以及微信开发者工具。</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101214631961.png" alt="下载"></p></li><li><h6 id="打开HBuilder点击文件新建1-项目"><a href="#打开HBuilder点击文件新建1-项目" class="headerlink" title="打开HBuilder点击文件新建1.项目"></a>打开HBuilder点击文件新建1.项目</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185031980.png" alt="新建"></p></li><li><h6 id="点击创建"><a href="#点击创建" class="headerlink" title="点击创建"></a>点击创建</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185118860.png" alt="创建"></p></li><li><h6 id="创建完之后就自动生成uniapp的文件目录树"><a href="#创建完之后就自动生成uniapp的文件目录树" class="headerlink" title="创建完之后就自动生成uniapp的文件目录树"></a>创建完之后就自动生成uniapp的文件目录树</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185258926.png" alt="生成"></p></li><li><h6 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h6><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185340190.png" alt="运行"></p><p><img src="/2021/11/01/uniapp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/image-20211101185546511.png" alt="运行结果"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一碗芋圆的碎碎念</title>
    <link href="/2021/10/29/%E4%B8%80%E7%A2%97%E8%8A%8B%E5%9C%86%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2021/10/29/%E4%B8%80%E7%A2%97%E8%8A%8B%E5%9C%86%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>爱情就是：白芋、紫芋、红豆、芋圆、牛奶————鲜鲜甜甜，每每回味，总有余香。</strong></p><p><img src="/2021/10/29/%E4%B8%80%E7%A2%97%E8%8A%8B%E5%9C%86%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/head.jpg" alt="相爱恨难"></p>]]></content>
    
    
    <categories>
      
      <category>-碎碎念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-爱情</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端渲染</title>
    <link href="/2021/10/29/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <url>/2021/10/29/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<ul><li><h5 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h5><ul><li>说白了就是在服务端使用模板引擎</li><li>模板引擎最早诞生于服务端，后来才发展到了前端</li></ul></li><li><h5 id="服务端渲染和客户端渲染的区别"><a href="#服务端渲染和客户端渲染的区别" class="headerlink" title="服务端渲染和客户端渲染的区别"></a>服务端渲染和客户端渲染的区别</h5><ul><li>客户端渲染不利于 SEO 搜索引擎优化</li><li>服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的</li><li>所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的</li><li>而是两者结合来做的</li><li>例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化</li><li>而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-服务端渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暂时性死区</title>
    <link href="/2021/10/29/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/"/>
    <url>/2021/10/29/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-keyword">let</span> tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async问题</title>
    <link href="/2021/10/29/async%E9%97%AE%E9%A2%98/"/>
    <url>/2021/10/29/async%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h4><ol><li>async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</li></ol><ul><li>补充：<code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</li></ul><p>在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><ol start="2"><li><p>async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。await 表达式的运算结果取决于它等的东西：</p><p>（1）如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p><p>（2）如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p></li></ol><h4 id="两者的共同作用"><a href="#两者的共同作用" class="headerlink" title="两者的共同作用"></a>两者的共同作用</h4><p>async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeLongTime</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-string">&quot;long_time_value&quot;</span>), <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">await</span> takeLongTime();<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br>test();<br></code></pre></div></td></tr></table></figure><h4 id="async-await-的优势在于处理-then-链"><a href="#async-await-的优势在于处理-then-链" class="headerlink" title="async/await 的优势在于处理 then 链"></a>async/await 的优势在于处理 then 链</h4><ol><li>promise实现三个步骤的处理</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeLongTime</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step1</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step2</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step3</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><span class="hljs-comment">/*-----------------------------------------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    step1(time1)<br>        .then(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> step2(time2))<br>        .then(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> step3(time3))<br>        .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><br>doIt();<br></code></pre></div></td></tr></table></figure><h4 id="async-await-来实现"><a href="#async-await-来实现" class="headerlink" title="async/await 来实现"></a>async/await 来实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> step1(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> step2(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> step3(time3);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><br>doIt();<br></code></pre></div></td></tr></table></figure><p>代码看起来清晰得多，几乎跟同步代码一样!!!</p><h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>)<br>    <span class="hljs-keyword">await</span> async2()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;,<span class="hljs-number">0</span>)  <br>async1();<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">答案：<br><span class="hljs-keyword">script</span> start<br>async1 start<br>async2<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br>promise2<br>async1 <span class="hljs-keyword">end</span><br>setTimeout<br></code></pre></div></td></tr></table></figure><h5 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h5><ol><li>定义一个异步函数 async1</li><li>定义一个异步函数 async2</li><li>打印 ‘script start’ // *1</li><li>定义一个定时器（宏任务，优先级低于微任务），在0ms 之后输出</li><li>执行异步函数 async1<ol><li>打印 ‘async1 start’ // *2</li><li>遇到await 表达式，执行 await 后面的 async2<ol><li>打印 ‘async2’ // *3</li></ol></li><li>返回一个 Promise，跳出 async1 函数体</li></ol></li><li>执行 new Promise 里的语句<ol><li>打印 ‘promise1‘    // *4</li><li>resolve() , 返回一个 Promise 对象，把这个 Promise 压进队列里</li></ol></li><li>打印 ’script end’  // *5</li><li>同步栈执行完毕</li><li>回到 async1 的函数体，async2 函数没有返回 Promise，所以把要等async2 的值 resolve，把 Promise 压进队列</li><li>执行 new Promise 后面的 .then，打印 ’promise2‘ // *6</li><li>回到 async1 的函数体，await 返回 Promise.resolve() ，然后打印后面的 ’async1 end‘  // *7</li><li>最后执行定时器（宏任务） setTimeout，打印 ’setTimeout‘ // *8</li></ol><p>我对这段代码的过程分析大致如上（如果有什么理解不对的地方请指出），这里有很关键而且是大家容易理解错误的点是：很多人以为 await 会一直等待后面的表达式执行完之后才会执行后续代码，实际上 await 是会先执行后面的表达式，然后返回一个Promise，接着就跳出整个 async 函数来执行后面的代码，也就是说执行到 await 的时候，会有一个 <strong>让出线程</strong> 的操作。等后面的同步站执行完了之后，又会回到 async 函数中等待 await 表达式的返回值，如果不是一个 Promise 对象，则会有一个期待它 resolve 成为一个 Promise对象的过程，然后继续执行 async 函数后面的代码，直到是一个 Promise 对象，则把这个 Promise 对象放入 Promise 队列里。</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>节流与防抖</title>
    <link href="/2021/10/29/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <url>/2021/10/29/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h3 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//throttle本质也是一个定时器，在第一次触发事件的时候，开启定时器，在定时器执行完毕之前，系统会锁住，新触发的事件都不会执行；定时器执行完毕之后，销毁定时器，系统开放，接受新的事件。</span><br><span class="hljs-comment">//基本函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Throttle</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">//设置初始时间</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//设置当前时间</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">if</span> (now - pre &gt; delay) &#123;<br>      func.apply(context, args);<br>      pre = now<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>​        两个参数，第一个参数就是执行的函数，第二个参数是延迟的时间，用节流的方式，可以保证在一段时间内，只有第一次执行是生效的直到超过了设定的时间段，才有机会执行下一次，大大的降低了原有函数的执行频率。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//进阶节流函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, options</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> timeout, context, args, result;<br>  <span class="hljs-keyword">var</span> previous = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!options) options = &#123;&#125;;<br> <br>  <span class="hljs-keyword">var</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    previous = options.leading === <span class="hljs-literal">false</span>? <span class="hljs-number">0</span>: <span class="hljs-built_in">Date</span>.now(); <br>    timeout = <span class="hljs-literal">null</span>;<br>    result = func.apply(context, args);<br>  &#125;;<br> <br>  <span class="hljs-keyword">var</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">if</span> (!previous &amp;&amp; options.leading === <span class="hljs-literal">false</span>) previous = now;<br>    <span class="hljs-keyword">var</span> remaining = wait - (now - previous);<br>  context = <span class="hljs-built_in">this</span>;<br>    args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) &#123;<br>      <span class="hljs-keyword">if</span> (timeout) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;<br>      previous = now;<br>      result = func.apply(context, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(later, remaining);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  throttled.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    previous = <span class="hljs-number">0</span>;<br>    timeout = context = args = <span class="hljs-literal">null</span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> throttled;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//debounce本质上，是一个定时器setTimeout，在wait毫秒时间之后，执行传入的函数：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, immediate</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout, result;<br> <br>    <span class="hljs-keyword">var</span> debounced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>  <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br> <br>        <span class="hljs-keyword">var</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           timeout = <span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">if</span> (!immediate) result = func.apply(context, args);<br>        &#125;;<br> <br> <br>        <span class="hljs-keyword">var</span> callNow = immediate &amp;&amp; !timeout;<br>        timeout = <span class="hljs-built_in">setTimeout</span>(later, wait);<br>        <span class="hljs-keyword">if</span> (callNow) result = func.apply(<span class="hljs-built_in">this</span>, args);<br> <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    debounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        timeout = <span class="hljs-literal">null</span>;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> debounced;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        返回 <strong>function</strong> 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 <strong>wait</strong> 毫秒之后. 对于必须在一些输入（多是一些用户操作）停止到达<em>之后</em>执行的行为有帮助。 例如: 渲染一个Markdown格式的评论预览, 当窗口停止改变大小之后重新计算布局, 等等.</p>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-throttle&amp;debounce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios</title>
    <link href="/2021/10/28/axios/"/>
    <url>/2021/10/28/axios/</url>
    
    <content type="html"><![CDATA[<h4 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h4><h5 id="1-请求地址以及超时时间"><a href="#1-请求地址以及超时时间" class="headerlink" title="1.请求地址以及超时时间"></a>1.请求地址以及超时时间</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://tomcat2-69.gis-data.cn:7080&#x27;</span>,<br>  <span class="hljs-comment">// 超时时间</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="2-设置请求拦截器"><a href="#2-设置请求拦截器" class="headerlink" title="2.设置请求拦截器"></a>2.设置请求拦截器</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">service.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  config.data = <span class="hljs-built_in">JSON</span>.stringify(config.data); <span class="hljs-comment">//数据转化,也可以使用qs转换</span><br>  config.headers = &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=UTF-8&#x27;</span> <span class="hljs-comment">//配置请求头</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> config<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">Promise</span>.reject(error)<br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="3-设置响应拦截器"><a href="#3-设置响应拦截器" class="headerlink" title="3.设置响应拦截器"></a>3.设置响应拦截器</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">service.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 接收到响应数据并成功后的一些共有的处理，关闭loading等</span><br><br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">/***** 接收到异常响应的处理开始 *****/</span><br>  <span class="hljs-keyword">if</span> (error &amp;&amp; error.response) &#123;<br>    <span class="hljs-comment">// 根据响应码具体处理</span><br>    <span class="hljs-keyword">switch</span> (error.response.status) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">400</span>:<br>        error.message = <span class="hljs-string">&#x27;错误请求&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:<br>        error.message = <span class="hljs-string">&#x27;未授权，请重新登录&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:<br>        error.message = <span class="hljs-string">&#x27;拒绝访问&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:<br>        error.message = <span class="hljs-string">&#x27;请求错误,未找到该资源&#x27;</span>;<br>        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;/NotFound&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">405</span>:<br>        error.message = <span class="hljs-string">&#x27;请求方法未允许&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">408</span>:<br>        error.message = <span class="hljs-string">&#x27;请求超时&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:<br>        error.message = <span class="hljs-string">&#x27;服务器端出错&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">501</span>:<br>        error.message = <span class="hljs-string">&#x27;网络未实现&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">502</span>:<br>        error.message = <span class="hljs-string">&#x27;网络错误&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">503</span>:<br>        error.message = <span class="hljs-string">&#x27;服务不可用&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">504</span>:<br>        error.message = <span class="hljs-string">&#x27;网络超时&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">505</span>:<br>        error.message = <span class="hljs-string">&#x27;http版本不支持该请求&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        error.message = <span class="hljs-string">`连接错误<span class="hljs-subst">$&#123;error.response.status&#125;</span>`</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 超时处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">JSON</span>.stringify(error).includes(<span class="hljs-string">&#x27;timeout&#x27;</span>)) &#123;<br>      Message.error(<span class="hljs-string">&#x27;服务器响应超时，请刷新当前页&#x27;</span>)<br>    &#125;<br>    error.message = <span class="hljs-string">&#x27;连接服务器失败&#x27;</span><br>  &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-返回错误信息，处理结束，最后导出"><a href="#4-返回错误信息，处理结束，最后导出" class="headerlink" title="4.返回错误信息，处理结束，最后导出"></a>4.返回错误信息，处理结束，最后导出</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"> Message.error(error.message);<br>  <span class="hljs-comment">/***** 处理结束 *****/</span><br>  <span class="hljs-comment">//如果不需要错误处理，以上的处理过程都可省略</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(error.response)<br>&#125;);<br><span class="hljs-comment">//导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生</title>
    <link href="/2021/10/28/cloud/"/>
    <url>/2021/10/28/cloud/</url>
    
    <content type="html"><![CDATA[<p>人生如戏,亦或是戏如人生。</p>]]></content>
    
    
    <categories>
      
      <category>-随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise</title>
    <link href="/2021/10/28/promise/"/>
    <url>/2021/10/28/promise/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//异步加载</span><br><span class="hljs-built_in">this</span>.promise = Cesium.GeoJsonDataSource.load(<br>  <span class="hljs-string">&#x27; http://nginx-100.gis-data.cn:7080/learning/3/cq-boundary.geojson&#x27;</span>, &#123;<br>    <span class="hljs-attr">stroke</span>: Cesium.Color.BLUE,<br>    <span class="hljs-attr">fill</span>: Cesium.Color.RED,<br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">8</span>,<br>  &#125;);<br><span class="hljs-built_in">this</span>.promise.then(<span class="hljs-function">(<span class="hljs-params">dataSource</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">this</span>.viewer.dataSources.add(dataSource);<br>  <span class="hljs-keyword">let</span> entities = dataSource.entities.values;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entity <span class="hljs-keyword">of</span> entities) &#123;<br>    <span class="hljs-keyword">let</span> polyPositions = entity.polygon.hierarchy.getValue(Cesium.JulianDate.now()).positions;<br>    <span class="hljs-comment">// 方式一：</span><br>    <span class="hljs-comment">// let polyCenter = Cesium.BoundingSphere.fromPoints(polyPositions).center;</span><br>    <span class="hljs-comment">// polyCenter = Cesium.Ellipsoid.WGS84.scaleToGeodeticSurface(polyCenter);</span><br>    <span class="hljs-comment">// 方式二：</span><br>    <span class="hljs-keyword">let</span> center = [];<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= polyPositions.length - <span class="hljs-number">1</span>; j++) &#123;<br>      a += polyPositions[j].x;<br>      b += polyPositions[j].y;<br>      c += polyPositions[j].z<br>    &#125;<br>    center = [a / polyPositions.length, b / polyPositions.length, c / polyPositions.length + <span class="hljs-number">2000</span>];<br>    <span class="hljs-keyword">let</span> labelpostion = Cesium.Cartesian3.fromArray(center);<br>    <span class="hljs-comment">//方式三：暂未实现，后面会继续研究</span><br>    <span class="hljs-comment">// let cartographics = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(polyPositions);</span><br>    <span class="hljs-comment">// let points = [];</span><br>    <span class="hljs-comment">// let center = [];</span><br>    <span class="hljs-comment">// let a = 0;</span><br>    <span class="hljs-comment">// for (let i = 0; i &lt;= cartographics.length - 1; i++) &#123;</span><br>    <span class="hljs-comment">//   let lat = Cesium.Math.toDegrees(cartographics[i].latitude);</span><br>    <span class="hljs-comment">//   let lng = Cesium.Math.toDegrees(cartographics[i].longitude);</span><br>    <span class="hljs-comment">//   a = cartographics[i].height;</span><br>    <span class="hljs-comment">//   points[i] = [lng, lat];</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// let polygon = Turf.polygon([points]);</span><br>    <span class="hljs-comment">// let centroid = Turf.centroid(polygon);</span><br>    <span class="hljs-comment">// center = [centroid.geometry.coordinates[0], centroid.geometry.coordinates[1]];</span><br>    <span class="hljs-comment">// let labelpostion = Cesium.Cartesian3.fromDegreesArray(center);</span><br>    <span class="hljs-built_in">this</span>.viewer.entities.add(&#123;<br>      <span class="hljs-attr">position</span>: labelpostion,<br>      <span class="hljs-attr">label</span>: &#123;<br>        <span class="hljs-attr">font</span>: <span class="hljs-string">&#x27;24px sans-serif&#x27;</span>,<br>        <span class="hljs-attr">text</span>: entity.name,<br>        <span class="hljs-attr">scale</span>: <span class="hljs-number">0.5</span>,<br>        <span class="hljs-attr">horizontalOrigin</span>: Cesium.HorizontalOrigin.CENTER,<br>        <span class="hljs-attr">verticalOrigin</span>: Cesium.VerticalOrigin.BOTTOM,<br>        <span class="hljs-attr">fillColor</span>: Cesium.Color.CRIMSON,<br>        <span class="hljs-attr">showBackground</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">backgroundColor</span>: Cesium.Color.BEIGE,<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>promise这个类最基本的功能就是传入处理器函数executor。根据MDN上的解释：</p><blockquote><p>这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。</p><p>promise中有三个状态：pending，fulfilled以及rejected。在上面这段程序中，使用this.$state来保存promise的状态。</p><p>而resolve和reject的函数定义当中，传入的参数res赋给this.$value，从而实现参数res的传递。</p><p>最后，调用executor，并把resolve和reject当做两个参数传递进去。如果这中间出现异常，我们会认为这是操作失败，从而调用reject函数。</p></blockquote><ul><li>在我的项目中，当执行cesium的Cesium.GeoJsonDataSource.load这个加载json格式的数据的函数时，会返回一个promise对象，此时promise对象resolve里储存的是entities实体数据集：它包括这个json数据的所有面的坐标数据，promise一般用.then方法获取resolve存储的数据，并且在then方法里的js都是异步进行的，在promise外面是获取不到这个数据的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>-技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
